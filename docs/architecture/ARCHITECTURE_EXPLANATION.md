# Объяснение архитектуры и решения проблемы

## Текущая архитектура (с проблемой)

```
┌─────────────────────────────────────────────────────────────┐
│  Server Component (app/page.tsx)                           │
│  └─> projectsServerProvider.getProjects()                    │
└─────────────────────────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│  ServerDataProvider (lib/server-data/base.ts)               │
│  └─> fetch('http://localhost:3000/api/projects') ❌        │
│      (Этот запрос НЕ РАБОТАЕТ в серверном контексте!)       │
└─────────────────────────────────────────────────────────────┘
                        │
                        ▼ (если бы работал)
┌─────────────────────────────────────────────────────────────┐
│  Route Handler (app/api/[entity]/route.ts)                  │
│  └─> getAuthTokens() из cookies                             │
│  └─> fetch(`${NEXT_PUBLIC_API_URL}/api/projects`) ✅        │
│      (Запрос к УДАЛЕННОМУ бэкенду)                          │
└─────────────────────────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│  Удаленный бэкенд (NEXT_PUBLIC_API_URL)                     │
│  └─> Возвращает данные проектов                             │
└─────────────────────────────────────────────────────────────┘
```

## Проблема

**Server Component делает HTTP fetch на свой же Next.js API**, что не работает в серверном контексте Next.js. Это приводит к 404 ошибке.

## Решение: Прямой вызов логики

### Что значит "прямой вызов"?

**НЕ означает:**

- ❌ Получение данных из клиентского компонента
- ❌ Отказ от запросов к удаленному бэкенду
- ❌ Изменение архитектуры получения данных

**Означает:**

- ✅ Вызов функции напрямую, без HTTP слоя внутри Next.js
- ✅ Убрать промежуточный HTTP запрос `fetch('http://localhost:3000/api/projects')`
- ✅ Вызвать ту же логику, что в route handler, но напрямую как функцию

### Новая архитектура (после исправления)

```
┌─────────────────────────────────────────────────────────────┐
│  Server Component (app/page.tsx)                             │
│  └─> projectsServerProvider.getProjects()                     │
└─────────────────────────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│  ServerDataProvider (lib/server-data/base.ts)                │
│  └─> getEntityData('projects', params) ✅                    │
│      (Прямой вызов функции, БЕЗ HTTP)                       │
└─────────────────────────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│  Серверная функция (lib/api/server.ts)                       │
│  └─> getAuthTokens() из cookies (прямой доступ)             │
│  └─> fetch(`${NEXT_PUBLIC_API_URL}/api/projects`) ✅        │
│      (Запрос к УДАЛЕННОМУ бэкенду - ОСТАЕТСЯ!)              │
└─────────────────────────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│  Удаленный бэкенд (NEXT_PUBLIC_API_URL)                      │
│  └─> Возвращает данные проектов                             │
└─────────────────────────────────────────────────────────────┘
```

## Что изменится?

### До исправления:

```typescript
// lib/server-data/base.ts
async getData(params) {
  // ❌ HTTP запрос внутри Next.js (не работает)
  const response = await fetch('http://localhost:3000/api/projects', {
    headers: { Cookie: cookieHeader }
  });
  return response.json();
}
```

### После исправления:

```typescript
// lib/server-data/base.ts
async getData(params) {
  // ✅ Прямой вызов функции (работает!)
  const data = await getEntityData('projects', params);
  return this.formatResponse(data);
}

// lib/api/server.ts
async function getEntityData(entity, params) {
  // ✅ Та же логика, что в route handler
  const tokens = await getAuthTokens(); // Прямой доступ к cookies
  const backendUrl = `${NEXT_PUBLIC_API_URL}/api/${entity}`;

  // ✅ Запрос к УДАЛЕННОМУ бэкенду (остается!)
  const response = await fetch(backendUrl, {
    headers: { Authorization: `Bearer ${tokens.accessToken}` }
  });
  return response.json();
}
```

## Важные моменты

### 1. Запрос к удаленному бэкенду ОСТАЕТСЯ

- ✅ Данные все равно получаются с `NEXT_PUBLIC_API_URL`
- ✅ Авторизация через токены работает
- ✅ Обработка ошибок и refresh токенов остается

### 2. При первом рендере (SSR)

- ✅ Данные получаются с удаленного бэкенда
- ✅ Просто без промежуточного HTTP слоя внутри Next.js
- ✅ Быстрее и эффективнее

### 3. Route Handler остается для клиентских компонентов

- ✅ Клиентские компоненты могут делать `fetch('/api/projects')`
- ✅ Route handler продолжает работать как прокси

## Итоговая архитектура

```
┌─────────────────────────────────────────────────────────────┐
│  КЛИЕНТСКИЕ КОМПОНЕНТЫ                                       │
│  └─> fetch('/api/projects')                                 │
│      └─> Route Handler → Удаленный бэкенд                   │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│  СЕРВЕРНЫЕ КОМПОНЕНТЫ (SSR)                                  │
│  └─> getEntityData('projects')                              │
│      └─> Прямой вызов → Удаленный бэкенд                    │
└─────────────────────────────────────────────────────────────┘
```

## Вывод

**"Прямой вызов"** = убрать HTTP слой внутри Next.js, но оставить запрос к удаленному бэкенду. Данные все равно получаются с удаленного сервера, просто более эффективно.
